/**
 * Vulnerability Management Tests
 * Tests for vulnerability scanning and management features
 */

describe('Vulnerability Management', () => {
  describe('Vulnerability Detection', () => {
    test('should detect vulnerabilities in dependencies', () => {
      const mockDependencies = [
        {
          name: 'lodash',
          version: '4.17.20',
          vulnerabilities: [
            {
              id: 'CVE-2021-23337',
              title: 'Prototype Pollution in lodash',
              severity: 'high',
              cvssScore: 7.2,
              affectedVersions: ['<4.17.21'],
              fixedVersion: '4.17.21'
            }
          ]
        },
        {
          name: 'react',
          version: '18.2.0',
          vulnerabilities: []
        }
      ];

      const vulnerableDeps = mockDependencies.filter(dep => dep.vulnerabilities.length > 0);
      const totalVulns = mockDependencies.reduce((sum, dep) => sum + dep.vulnerabilities.length, 0);

      expect(vulnerableDeps.length).toBe(1);
      expect(totalVulns).toBe(1);
      expect(vulnerableDeps[0].name).toBe('lodash');
    });

    test('should categorize vulnerabilities by severity', () => {
      const vulnerabilities = [
        { severity: 'critical', cvssScore: 9.0 },
        { severity: 'high', cvssScore: 7.5 },
        { severity: 'high', cvssScore: 8.0 },
        { severity: 'medium', cvssScore: 5.0 },
        { severity: 'low', cvssScore: 2.0 }
      ];

      const categorizeVulnerabilities = (vulns) => {
        return vulns.reduce((acc, vuln) => {
          acc[vuln.severity] = (acc[vuln.severity] || 0) + 1;
          return acc;
        }, {});
      };

      const categories = categorizeVulnerabilities(vulnerabilities);

      expect(categories.critical).toBe(1);
      expect(categories.high).toBe(2);
      expect(categories.medium).toBe(1);
      expect(categories.low).toBe(1);
    });

    test('should prioritize vulnerabilities by severity and CVSS score', () => {
      const vulnerabilities = [
        { id: '1', severity: 'medium', cvssScore: 5.0 },
        { id: '2', severity: 'critical', cvssScore: 9.0 },
        { id: '3', severity: 'high', cvssScore: 7.5 },
        { id: '4', severity: 'critical', cvssScore: 8.5 },
        { id: '5', severity: 'low', cvssScore: 2.0 }
      ];

      const prioritizeVulnerabilities = (vulns) => {
        const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
        return vulns.sort((a, b) => {
          const severityDiff = severityOrder[b.severity] - severityOrder[a.severity];
          if (severityDiff !== 0) return severityDiff;
          return b.cvssScore - a.cvssScore;
        });
      };

      const prioritized = prioritizeVulnerabilities([...vulnerabilities]);

      expect(prioritized[0].id).toBe('2'); // Critical with highest CVSS
      expect(prioritized[1].id).toBe('4'); // Critical with lower CVSS
      expect(prioritized[2].id).toBe('3'); // High severity
      expect(prioritized[3].id).toBe('1'); // Medium severity
      expect(prioritized[4].id).toBe('5'); // Low severity
    });
  });

  describe('Dependency Scanning', () => {
    test('should parse package.json dependencies', () => {
      const mockPackageJson = {
        dependencies: {
          'react': '^18.2.0',
          'lodash': '^4.17.20',
          '@supabase/supabase-js': '^2.38.0'
        },
        devDependencies: {
          'jest': '^29.0.0',
          'typescript': '^5.0.0'
        }
      };

      const parseDependencies = (packageJson) => {
        const deps = Object.keys(packageJson.dependencies || {});
        const devDeps = Object.keys(packageJson.devDependencies || {});
        return {
          production: deps,
          development: devDeps,
          total: deps.length + devDeps.length
        };
      };

      const result = parseDependencies(mockPackageJson);

      expect(result.production.length).toBe(3);
      expect(result.development.length).toBe(2);
      expect(result.total).toBe(5);
      expect(result.production).toContain('react');
      expect(result.development).toContain('jest');
    });

    test('should detect outdated dependencies', () => {
      const dependencies = [
        {
          name: 'react',
          currentVersion: '18.2.0',
          latestVersion: '18.2.0',
          lastUpdated: new Date('2023-06-15')
        },
        {
          name: 'lodash',
          currentVersion: '4.17.20',
          latestVersion: '4.17.21',
          lastUpdated: new Date('2020-05-01')
        }
      ];

      const checkOutdated = (deps) => {
        const now = new Date();
        return deps.map(dep => {
          const monthsBehind = Math.floor((now.getTime() - dep.lastUpdated.getTime()) / (30 * 24 * 60 * 60 * 1000));
          const isOutdated = dep.currentVersion !== dep.latestVersion || monthsBehind > 6;
          
          return {
            ...dep,
            isOutdated,
            monthsBehind,
            needsUpdate: isOutdated
          };
        });
      };

      const results = checkOutdated(dependencies);
      const outdated = results.filter(dep => dep.isOutdated);

      expect(outdated.length).toBeGreaterThan(0);
      expect(outdated[0].name).toBe('lodash');
      expect(outdated[0].monthsBehind).toBeGreaterThan(12);
    });

    test('should simulate npm audit results', () => {
      const mockAuditResult = {
        advisories: {
          '1179': {
            id: 1179,
            title: 'Prototype Pollution in lodash',
            module_name: 'lodash',
            severity: 'high',
            cves: ['CVE-2021-23337'],
            vulnerable_versions: '<4.17.21',
            patched_versions: '>=4.17.21'
          }
        },
        metadata: {
          vulnerabilities: {
            critical: 0,
            high: 1,
            moderate: 0,
            low: 0
          },
          totalDependencies: 10
        }
      };

      const parseAuditResult = (audit) => {
        const vulnerabilities = [];
        for (const [id, advisory] of Object.entries(audit.advisories)) {
          vulnerabilities.push({
            id: `npm-${advisory.id}`,
            title: advisory.title,
            package: advisory.module_name,
            severity: advisory.severity,
            cves: advisory.cves,
            vulnerable: advisory.vulnerable_versions,
            fixed: advisory.patched_versions
          });
        }
        return {
          vulnerabilities,
          summary: audit.metadata.vulnerabilities
        };
      };

      const result = parseAuditResult(mockAuditResult);

      expect(result.vulnerabilities.length).toBe(1);
      expect(result.vulnerabilities[0].package).toBe('lodash');
      expect(result.summary.high).toBe(1);
    });
  });

  describe('License Compliance', () => {
    test('should check license compatibility', () => {
      const dependencies = [
        { name: 'react', license: 'MIT' },
        { name: 'lodash', license: 'MIT' },
        { name: 'some-gpl-package', license: 'GPL-3.0' },
        { name: 'unknown-package', license: 'Unknown' }
      ];

      const checkLicenseCompliance = (deps) => {
        const compatibleLicenses = ['MIT', 'Apache-2.0', 'BSD-2-Clause', 'BSD-3-Clause', 'ISC'];
        const problematicLicenses = ['GPL-2.0', 'GPL-3.0', 'AGPL-3.0'];

        return deps.map(dep => {
          let riskLevel = 'low';
          let isCompatible = true;
          const issues = [];

          if (!dep.license || dep.license === 'Unknown') {
            riskLevel = 'high';
            isCompatible = false;
            issues.push('License information missing');
          } else if (problematicLicenses.includes(dep.license)) {
            riskLevel = 'high';
            isCompatible = false;
            issues.push('Copyleft license may require source disclosure');
          } else if (!compatibleLicenses.includes(dep.license)) {
            riskLevel = 'medium';
            issues.push('License compatibility needs review');
          }

          return {
            ...dep,
            isCompatible,
            riskLevel,
            issues
          };
        });
      };

      const results = checkLicenseCompliance(dependencies);
      const incompatible = results.filter(dep => !dep.isCompatible);

      expect(incompatible.length).toBe(2);
      expect(incompatible.some(dep => dep.name === 'some-gpl-package')).toBe(true);
      expect(incompatible.some(dep => dep.name === 'unknown-package')).toBe(true);
    });

    test('should categorize license risks', () => {
      const licenseResults = [
        { name: 'pkg1', riskLevel: 'low' },
        { name: 'pkg2', riskLevel: 'medium' },
        { name: 'pkg3', riskLevel: 'high' },
        { name: 'pkg4', riskLevel: 'low' }
      ];

      const categorizeLicenseRisks = (results) => {
        return results.reduce((acc, result) => {
          acc[result.riskLevel] = (acc[result.riskLevel] || 0) + 1;
          return acc;
        }, {});
      };

      const categories = categorizeLicenseRisks(licenseResults);

      expect(categories.low).toBe(2);
      expect(categories.medium).toBe(1);
      expect(categories.high).toBe(1);
    });
  });

  describe('Security Patch Management', () => {
    test('should create security patches', () => {
      const createSecurityPatch = (title, description, severity, affectedComponents) => {
        return {
          id: `patch_${Date.now()}`,
          title,
          description,
          severity,
          affectedComponents,
          status: 'available',
          createdDate: new Date(),
          appliedDate: null
        };
      };

      const patch = createSecurityPatch(
        'Fix lodash vulnerability',
        'Update lodash to version 4.17.21',
        'high',
        ['lodash']
      );

      expect(patch.title).toBe('Fix lodash vulnerability');
      expect(patch.severity).toBe('high');
      expect(patch.status).toBe('available');
      expect(patch.affectedComponents).toContain('lodash');
    });

    test('should apply security patches', () => {
      const patches = new Map();
      
      const applyPatch = (patchId) => {
        const patch = patches.get(patchId);
        if (!patch) return { success: false, error: 'Patch not found' };

        patch.status = 'applied';
        patch.appliedDate = new Date();
        patches.set(patchId, patch);

        return { success: true };
      };

      // Create a patch
      const patch = {
        id: 'patch_123',
        title: 'Security fix',
        status: 'available',
        appliedDate: null
      };
      patches.set(patch.id, patch);

      // Apply the patch
      const result = applyPatch('patch_123');
      const updatedPatch = patches.get('patch_123');

      expect(result.success).toBe(true);
      expect(updatedPatch.status).toBe('applied');
      expect(updatedPatch.appliedDate).toBeInstanceOf(Date);
    });

    test('should track patch application status', () => {
      const patches = [
        { id: '1', status: 'available' },
        { id: '2', status: 'applied' },
        { id: '3', status: 'failed' },
        { id: '4', status: 'applied' }
      ];

      const getPatchStatistics = (patches) => {
        return patches.reduce((acc, patch) => {
          acc[patch.status] = (acc[patch.status] || 0) + 1;
          return acc;
        }, {});
      };

      const stats = getPatchStatistics(patches);

      expect(stats.available).toBe(1);
      expect(stats.applied).toBe(2);
      expect(stats.failed).toBe(1);
    });
  });

  describe('Vulnerability Scanning', () => {
    test('should perform dependency scan', () => {
      const performDependencyScan = () => {
        const scanId = `scan_${Date.now()}`;
        const vulnerabilities = [
          {
            id: 'vuln_1',
            severity: 'high',
            package: 'lodash',
            description: 'Prototype pollution vulnerability'
          },
          {
            id: 'vuln_2',
            severity: 'medium',
            package: 'old-package',
            description: 'Outdated package with known issues'
          }
        ];

        return {
          scanId,
          timestamp: new Date(),
          type: 'dependency',
          vulnerabilities,
          summary: {
            total: vulnerabilities.length,
            critical: 0,
            high: 1,
            medium: 1,
            low: 0
          }
        };
      };

      const scanResult = performDependencyScan();

      expect(scanResult.scanId).toBeDefined();
      expect(scanResult.type).toBe('dependency');
      expect(scanResult.vulnerabilities.length).toBe(2);
      expect(scanResult.summary.high).toBe(1);
      expect(scanResult.summary.medium).toBe(1);
    });

    test('should perform configuration scan', () => {
      const performConfigurationScan = () => {
        const issues = [];

        // Check environment variables
        const requiredEnvVars = ['SUPABASE_URL', 'SUPABASE_ANON_KEY'];
        for (const envVar of requiredEnvVars) {
          if (!process.env[envVar]) {
            issues.push({
              id: `missing_env_${envVar}`,
              severity: 'high',
              description: `Missing required environment variable: ${envVar}`
            });
          }
        }

        // Check security settings
        const securitySettings = {
          httpsEnforced: true,
          dataEncryption: true,
          securityHeaders: true
        };

        for (const [setting, enabled] of Object.entries(securitySettings)) {
          if (!enabled) {
            issues.push({
              id: `security_${setting}`,
              severity: 'medium',
              description: `Security setting ${setting} is disabled`
            });
          }
        }

        return {
          scanId: `config_scan_${Date.now()}`,
          type: 'configuration',
          issues,
          summary: {
            total: issues.length,
            high: issues.filter(i => i.severity === 'high').length,
            medium: issues.filter(i => i.severity === 'medium').length
          }
        };
      };

      const scanResult = performConfigurationScan();

      expect(scanResult.type).toBe('configuration');
      expect(Array.isArray(scanResult.issues)).toBe(true);
      expect(scanResult.summary.total).toBe(scanResult.issues.length);
    });
  });

  describe('Vulnerability Reporting', () => {
    test('should generate vulnerability report', () => {
      const vulnerabilities = [
        { severity: 'critical', status: 'open' },
        { severity: 'high', status: 'open' },
        { severity: 'high', status: 'fixed' },
        { severity: 'medium', status: 'open' },
        { severity: 'low', status: 'ignored' }
      ];

      const generateReport = (vulns) => {
        const bySeverity = vulns.reduce((acc, vuln) => {
          acc[vuln.severity] = (acc[vuln.severity] || 0) + 1;
          return acc;
        }, {});

        const byStatus = vulns.reduce((acc, vuln) => {
          acc[vuln.status] = (acc[vuln.status] || 0) + 1;
          return acc;
        }, {});

        const openVulns = vulns.filter(v => v.status === 'open');
        const criticalOpen = openVulns.filter(v => v.severity === 'critical').length;

        return {
          total: vulns.length,
          bySeverity,
          byStatus,
          openVulnerabilities: openVulns.length,
          criticalOpen,
          riskScore: criticalOpen * 10 + openVulns.filter(v => v.severity === 'high').length * 5
        };
      };

      const report = generateReport(vulnerabilities);

      expect(report.total).toBe(5);
      expect(report.bySeverity.critical).toBe(1);
      expect(report.byStatus.open).toBe(3);
      expect(report.criticalOpen).toBe(1);
      expect(report.riskScore).toBeGreaterThan(0);
    });

    test('should generate recommendations', () => {
      const vulnerabilities = [
        { severity: 'critical', package: 'lodash', status: 'open' },
        { severity: 'high', package: 'old-lib', status: 'open' },
        { severity: 'medium', package: 'some-dep', status: 'open' }
      ];

      const generateRecommendations = (vulns) => {
        const recommendations = [];
        const openVulns = vulns.filter(v => v.status === 'open');
        
        const critical = openVulns.filter(v => v.severity === 'critical');
        const high = openVulns.filter(v => v.severity === 'high');
        const medium = openVulns.filter(v => v.severity === 'medium');

        if (critical.length > 0) {
          recommendations.push(`Immediately address ${critical.length} critical vulnerabilities`);
        }

        if (high.length > 0) {
          recommendations.push(`Plan to fix ${high.length} high-severity vulnerabilities within 7 days`);
        }

        if (medium.length > 5) {
          recommendations.push(`Consider addressing ${medium.length} medium-severity vulnerabilities`);
        }

        // Package-specific recommendations
        const packageCounts = new Map();
        for (const vuln of openVulns) {
          packageCounts.set(vuln.package, (packageCounts.get(vuln.package) || 0) + 1);
        }

        for (const [pkg, count] of packageCounts.entries()) {
          if (count > 1) {
            recommendations.push(`Package '${pkg}' has ${count} vulnerabilities - consider updating`);
          }
        }

        return recommendations;
      };

      const recommendations = generateRecommendations(vulnerabilities);

      expect(recommendations.length).toBeGreaterThan(0);
      expect(recommendations.some(r => r.includes('critical'))).toBe(true);
      expect(recommendations.some(r => r.includes('high-severity'))).toBe(true);
    });
  });

  describe('Integration Tests', () => {
    test('should handle complete vulnerability management workflow', () => {
      const vulnerabilityWorkflow = {
        scanDependencies: () => ({
          vulnerabilities: [
            { id: '1', severity: 'high', package: 'lodash', status: 'open' }
          ]
        }),
        createPatch: (vulnId) => ({
          id: `patch_${vulnId}`,
          status: 'available',
          targetVulnerability: vulnId
        }),
        applyPatch: (patchId) => ({ success: true, patchId }),
        updateVulnerabilityStatus: (vulnId, status) => ({ vulnId, status })
      };

      // Run scan
      const scanResult = vulnerabilityWorkflow.scanDependencies();
      expect(scanResult.vulnerabilities.length).toBe(1);

      // Create patch
      const vulnerability = scanResult.vulnerabilities[0];
      const patch = vulnerabilityWorkflow.createPatch(vulnerability.id);
      expect(patch.targetVulnerability).toBe(vulnerability.id);

      // Apply patch
      const applyResult = vulnerabilityWorkflow.applyPatch(patch.id);
      expect(applyResult.success).toBe(true);

      // Update vulnerability status
      const updateResult = vulnerabilityWorkflow.updateVulnerabilityStatus(vulnerability.id, 'fixed');
      expect(updateResult.status).toBe('fixed');
    });

    test('should prioritize vulnerability remediation', () => {
      const vulnerabilities = [
        { id: '1', severity: 'low', cvssScore: 2.0, package: 'pkg1' },
        { id: '2', severity: 'critical', cvssScore: 9.0, package: 'pkg2' },
        { id: '3', severity: 'high', cvssScore: 7.5, package: 'pkg3' },
        { id: '4', severity: 'medium', cvssScore: 5.0, package: 'pkg4' }
      ];

      const prioritizeRemediation = (vulns) => {
        const immediate = vulns.filter(v => v.severity === 'critical');
        const urgent = vulns.filter(v => v.severity === 'high');
        const planned = vulns.filter(v => v.severity === 'medium');
        const optional = vulns.filter(v => v.severity === 'low');

        return { immediate, urgent, planned, optional };
      };

      const prioritized = prioritizeRemediation(vulnerabilities);

      expect(prioritized.immediate.length).toBe(1);
      expect(prioritized.urgent.length).toBe(1);
      expect(prioritized.planned.length).toBe(1);
      expect(prioritized.optional.length).toBe(1);
      expect(prioritized.immediate[0].severity).toBe('critical');
    });
  });
});