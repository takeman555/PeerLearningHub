/**
 * Vulnerability Management Service
 * Handles dependency scanning, security patches, and vulnerability monitoring
 */

import { productionSecurityConfig, vulnerabilityConfig } from '../config/security';
import { securityService } from './securityService';

export interface Vulnerability {
  id: string;
  title: string;
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  cvssScore: number;
  cveId?: string;
  affectedPackage: string;
  affectedVersions: string[];
  fixedVersion?: string;
  publishedDate: Date;
  discoveredDate: Date;
  status: 'open' | 'acknowledged' | 'fixed' | 'ignored';
  source: 'npm_audit' | 'github_advisory' | 'manual' | 'automated_scan';
}

export interface DependencyInfo {
  name: string;
  version: string;
  type: 'direct' | 'transitive';
  license: string;
  lastUpdated: Date;
  isOutdated: boolean;
  latestVersion?: string;
  monthsBehind?: number;
  vulnerabilities: Vulnerability[];
}

export interface SecurityPatch {
  id: string;
  title: string;
  description: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  affectedComponents: string[];
  patchVersion: string;
  releaseDate: Date;
  appliedDate?: Date;
  status: 'available' | 'applied' | 'failed' | 'rollback';
  rollbackPlan?: string;
}

export interface ScanResult {
  scanId: string;
  scanType: 'dependency' | 'code' | 'configuration' | 'infrastructure';
  timestamp: Date;
  duration: number;
  vulnerabilities: Vulnerability[];
  summary: {
    total: number;
    critical: number;
    high: number;
    medium: number;
    low: number;
  };
  recommendations: string[];
}

export class VulnerabilityManagementService {
  private static instance: VulnerabilityManagementService;
  private vulnerabilities: Map<string, Vulnerability> = new Map();
  private dependencies: Map<string, DependencyInfo> = new Map();
  private securityPatches: Map<string, SecurityPatch> = new Map();
  private scanHistory: ScanResult[] = [];

  private constructor() {
    this.initializeVulnerabilityManagement();
  }

  static getInstance(): VulnerabilityManagementService {
    if (!VulnerabilityManagementService.instance) {
      VulnerabilityManagementService.instance = new VulnerabilityManagementService();
    }
    return VulnerabilityManagementService.instance;
  }

  /**
   * Initialize vulnerability management
   */
  private initializeVulnerabilityManagement(): void {
    if (vulnerabilityConfig.enableScanning) {
      // Start periodic vulnerability scanning
      this.startPeriodicScanning();
    }

    // Load initial dependency information
    this.loadDependencyInformation();
  }

  /**
   * Start periodic vulnerability scanning
   */
  private startPeriodicScanning(): void {
    // Run dependency scan every 24 hours
    setInterval(async () => {
      try {
        await this.scanDependencies();
      } catch (error) {
        console.error('Periodic dependency scan failed:', error);
      }
    }, vulnerabilityConfig.scanInterval);

    // Run configuration scan every week
    setInterval(async () => {
      try {
        await this.scanConfiguration();
      } catch (error) {
        console.error('Periodic configuration scan failed:', error);
      }
    }, 7 * 24 * 60 * 60 * 1000); // 7 days
  }

  /**
   * Load dependency information from package.json
   */
  private async loadDependencyInformation(): Promise<void> {
    try {
      // In a real implementation, this would read package.json and package-lock.json
      // For now, we'll simulate with common React Native dependencies
      const mockDependencies: DependencyInfo[] = [
        {
          name: 'react',
          version: '18.2.0',
          type: 'direct',
          license: 'MIT',
          lastUpdated: new Date('2023-06-15'),
          isOutdated: false,
          vulnerabilities: [],
        },
        {
          name: 'react-native',
          version: '0.72.0',
          type: 'direct',
          license: 'MIT',
          lastUpdated: new Date('2023-06-20'),
          isOutdated: true,
          latestVersion: '0.73.2',
          monthsBehind: 2,
          vulnerabilities: [],
        },
        {
          name: '@supabase/supabase-js',
          version: '2.38.0',
          type: 'direct',
          license: 'MIT',
          lastUpdated: new Date('2023-10-15'),
          isOutdated: false,
          vulnerabilities: [],
        },
        {
          name: 'lodash',
          version: '4.17.20',
          type: 'transitive',
          license: 'MIT',
          lastUpdated: new Date('2020-05-01'),
          isOutdated: true,
          latestVersion: '4.17.21',
          monthsBehind: 36,
          vulnerabilities: [
            {
              id: 'GHSA-35jh-r3h4-6jhm',
              title: 'Prototype Pollution in lodash',
              description: 'lodash versions prior to 4.17.21 are vulnerable to Command Injection via template.',
              severity: 'high',
              cvssScore: 7.2,
              cveId: 'CVE-2021-23337',
              affectedPackage: 'lodash',
              affectedVersions: ['<4.17.21'],
              fixedVersion: '4.17.21',
              publishedDate: new Date('2021-02-15'),
              discoveredDate: new Date(),
              status: 'open',
              source: 'github_advisory',
            },
          ],
        },
      ];

      for (const dep of mockDependencies) {
        this.dependencies.set(dep.name, dep);
      }

      console.log(`Loaded ${mockDependencies.length} dependencies`);
    } catch (error) {
      console.error('Failed to load dependency information:', error);
    }
  }

  /**
   * Scan dependencies for vulnerabilities
   */
  async scanDependencies(): Promise<ScanResult> {
    const scanId = this.generateScanId();
    const startTime = Date.now();
    const vulnerabilities: Vulnerability[] = [];

    try {
      console.log('Starting dependency vulnerability scan...');

      // Simulate npm audit
      const auditResults = await this.runNpmAudit();
      vulnerabilities.push(...auditResults);

      // Check for outdated packages
      const outdatedResults = await this.checkOutdatedPackages();
      vulnerabilities.push(...outdatedResults);

      // Check against GitHub Security Advisories
      const advisoryResults = await this.checkGitHubAdvisories();
      vulnerabilities.push(...advisoryResults);

      const duration = Date.now() - startTime;
      const summary = this.calculateVulnerabilitySummary(vulnerabilities);

      const scanResult: ScanResult = {
        scanId,
        scanType: 'dependency',
        timestamp: new Date(),
        duration,
        vulnerabilities,
        summary,
        recommendations: this.generateRecommendations(vulnerabilities),
      };

      this.scanHistory.push(scanResult);

      // Store vulnerabilities
      for (const vuln of vulnerabilities) {
        this.vulnerabilities.set(vuln.id, vuln);
      }

      console.log(`Dependency scan completed: ${vulnerabilities.length} vulnerabilities found`);
      return scanResult;
    } catch (error) {
      console.error('Dependency scan failed:', error);
      throw new Error('Dependency vulnerability scan failed');
    }
  }

  /**
   * Simulate npm audit
   */
  private async runNpmAudit(): Promise<Vulnerability[]> {
    // In a real implementation, this would run `npm audit --json`
    // For now, we'll return vulnerabilities from our mock dependencies
    const vulnerabilities: Vulnerability[] = [];

    for (const [name, dep] of this.dependencies.entries()) {
      vulnerabilities.push(...dep.vulnerabilities);
    }

    return vulnerabilities;
  }

  /**
   * Check for outdated packages
   */
  private async checkOutdatedPackages(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    for (const [name, dep] of this.dependencies.entries()) {
      if (dep.isOutdated && dep.monthsBehind && dep.monthsBehind > 12) {
        vulnerabilities.push({
          id: `outdated-${name}`,
          title: `Outdated package: ${name}`,
          description: `Package ${name} is ${dep.monthsBehind} months behind the latest version`,
          severity: dep.monthsBehind > 24 ? 'medium' : 'low',
          cvssScore: dep.monthsBehind > 24 ? 4.0 : 2.0,
          affectedPackage: name,
          affectedVersions: [dep.version],
          fixedVersion: dep.latestVersion,
          publishedDate: new Date(),
          discoveredDate: new Date(),
          status: 'open',
          source: 'automated_scan',
        });
      }
    }

    return vulnerabilities;
  }

  /**
   * Check GitHub Security Advisories
   */
  private async checkGitHubAdvisories(): Promise<Vulnerability[]> {
    // In a real implementation, this would query GitHub's GraphQL API
    // For now, we'll return mock advisories
    return [
      {
        id: 'GHSA-mock-advisory',
        title: 'Example Security Advisory',
        description: 'This is a mock security advisory for demonstration purposes',
        severity: 'low',
        cvssScore: 3.1,
        affectedPackage: 'example-package',
        affectedVersions: ['<1.0.0'],
        fixedVersion: '1.0.0',
        publishedDate: new Date('2024-01-01'),
        discoveredDate: new Date(),
        status: 'open',
        source: 'github_advisory',
      },
    ];
  }

  /**
   * Scan configuration for security issues
   */
  async scanConfiguration(): Promise<ScanResult> {
    const scanId = this.generateScanId();
    const startTime = Date.now();
    const vulnerabilities: Vulnerability[] = [];

    try {
      console.log('Starting configuration security scan...');

      // Check environment variables
      const envVulns = this.checkEnvironmentVariables();
      vulnerabilities.push(...envVulns);

      // Check file permissions
      const permVulns = this.checkFilePermissions();
      vulnerabilities.push(...permVulns);

      // Check security configurations
      const configVulns = this.checkSecurityConfigurations();
      vulnerabilities.push(...configVulns);

      const duration = Date.now() - startTime;
      const summary = this.calculateVulnerabilitySummary(vulnerabilities);

      const scanResult: ScanResult = {
        scanId,
        scanType: 'configuration',
        timestamp: new Date(),
        duration,
        vulnerabilities,
        summary,
        recommendations: this.generateRecommendations(vulnerabilities),
      };

      this.scanHistory.push(scanResult);

      console.log(`Configuration scan completed: ${vulnerabilities.length} issues found`);
      return scanResult;
    } catch (error) {
      console.error('Configuration scan failed:', error);
      throw new Error('Configuration security scan failed');
    }
  }

  /**
   * Check environment variables for security issues
   */
  private checkEnvironmentVariables(): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    // Check for missing required environment variables
    const requiredEnvVars = [
      'EXPO_PUBLIC_SUPABASE_URL',
      'EXPO_PUBLIC_SUPABASE_ANON_KEY',
      'SUPABASE_SERVICE_ROLE_KEY',
    ];

    for (const envVar of requiredEnvVars) {
      if (!process.env[envVar]) {
        vulnerabilities.push({
          id: `missing-env-${envVar}`,
          title: `Missing environment variable: ${envVar}`,
          description: `Required environment variable ${envVar} is not set`,
          severity: 'high',
          cvssScore: 7.5,
          affectedPackage: 'configuration',
          affectedVersions: ['current'],
          publishedDate: new Date(),
          discoveredDate: new Date(),
          status: 'open',
          source: 'automated_scan',
        });
      }
    }

    // Check for insecure default values
    if (process.env.EXPO_PUBLIC_SUPABASE_URL?.includes('placeholder')) {
      vulnerabilities.push({
        id: 'insecure-supabase-url',
        title: 'Insecure Supabase URL configuration',
        description: 'Supabase URL contains placeholder values',
        severity: 'critical',
        cvssScore: 9.0,
        affectedPackage: 'configuration',
        affectedVersions: ['current'],
        publishedDate: new Date(),
        discoveredDate: new Date(),
        status: 'open',
        source: 'automated_scan',
      });
    }

    return vulnerabilities;
  }

  /**
   * Check file permissions
   */
  private checkFilePermissions(): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    // In a real implementation, this would check actual file permissions
    // For now, we'll simulate common permission issues
    const sensitiveFiles = [
      '.env',
      '.env.production',
      'private-key.pem',
      'service-account.json',
    ];

    for (const file of sensitiveFiles) {
      // Simulate finding files with overly permissive permissions
      if (Math.random() > 0.8) { // 20% chance of finding an issue
        vulnerabilities.push({
          id: `file-permission-${file}`,
          title: `Insecure file permissions: ${file}`,
          description: `File ${file} has overly permissive permissions`,
          severity: 'medium',
          cvssScore: 5.0,
          affectedPackage: 'filesystem',
          affectedVersions: ['current'],
          publishedDate: new Date(),
          discoveredDate: new Date(),
          status: 'open',
          source: 'automated_scan',
        });
      }
    }

    return vulnerabilities;
  }

  /**
   * Check security configurations
   */
  private checkSecurityConfigurations(): Vulnerability[] {
    const vulnerabilities: Vulnerability[] = [];

    // Check if security features are enabled
    if (!productionSecurityConfig.encryption.enableDataEncryption) {
      vulnerabilities.push({
        id: 'data-encryption-disabled',
        title: 'Data encryption is disabled',
        description: 'Data encryption should be enabled in production',
        severity: 'high',
        cvssScore: 7.0,
        affectedPackage: 'configuration',
        affectedVersions: ['current'],
        publishedDate: new Date(),
        discoveredDate: new Date(),
        status: 'open',
        source: 'automated_scan',
      });
    }

    if (!productionSecurityConfig.api.enableHttpsOnly) {
      vulnerabilities.push({
        id: 'https-not-enforced',
        title: 'HTTPS enforcement is disabled',
        description: 'HTTPS should be enforced for all API communications',
        severity: 'critical',
        cvssScore: 8.5,
        affectedPackage: 'configuration',
        affectedVersions: ['current'],
        publishedDate: new Date(),
        discoveredDate: new Date(),
        status: 'open',
        source: 'automated_scan',
      });
    }

    return vulnerabilities;
  }

  /**
   * Apply security patch
   */
  async applySecurityPatch(patchId: string): Promise<{ success: boolean; error?: string }> {
    try {
      const patch = this.securityPatches.get(patchId);
      if (!patch) {
        return { success: false, error: 'Patch not found' };
      }

      console.log(`Applying security patch: ${patch.title}`);

      // In a real implementation, this would:
      // 1. Create a backup
      // 2. Apply the patch (update dependencies, configuration, etc.)
      // 3. Run tests
      // 4. Verify the fix

      // Simulate patch application
      await new Promise(resolve => setTimeout(resolve, 2000));

      // Update patch status
      patch.status = 'applied';
      patch.appliedDate = new Date();
      this.securityPatches.set(patchId, patch);

      // Mark related vulnerabilities as fixed
      for (const component of patch.affectedComponents) {
        for (const [vulnId, vuln] of this.vulnerabilities.entries()) {
          if (vuln.affectedPackage === component) {
            vuln.status = 'fixed';
            this.vulnerabilities.set(vulnId, vuln);
          }
        }
      }

      console.log(`Security patch applied successfully: ${patch.title}`);
      return { success: true };
    } catch (error) {
      console.error('Failed to apply security patch:', error);
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
    }
  }

  /**
   * Create security patch
   */
  createSecurityPatch(
    title: string,
    description: string,
    severity: SecurityPatch['severity'],
    affectedComponents: string[],
    patchVersion: string
  ): string {
    const patchId = this.generatePatchId();
    
    const patch: SecurityPatch = {
      id: patchId,
      title,
      description,
      severity,
      affectedComponents,
      patchVersion,
      releaseDate: new Date(),
      status: 'available',
      rollbackPlan: `Rollback to previous version if issues occur`,
    };

    this.securityPatches.set(patchId, patch);
    console.log(`Security patch created: ${title}`);
    
    return patchId;
  }

  /**
   * Get vulnerability by ID
   */
  getVulnerability(id: string): Vulnerability | null {
    return this.vulnerabilities.get(id) || null;
  }

  /**
   * List vulnerabilities with filtering
   */
  listVulnerabilities(filter?: {
    severity?: Vulnerability['severity'];
    status?: Vulnerability['status'];
    source?: Vulnerability['source'];
    package?: string;
  }): Vulnerability[] {
    let vulnerabilities = Array.from(this.vulnerabilities.values());

    if (filter) {
      if (filter.severity) {
        vulnerabilities = vulnerabilities.filter(v => v.severity === filter.severity);
      }
      if (filter.status) {
        vulnerabilities = vulnerabilities.filter(v => v.status === filter.status);
      }
      if (filter.source) {
        vulnerabilities = vulnerabilities.filter(v => v.source === filter.source);
      }
      if (filter.package) {
        vulnerabilities = vulnerabilities.filter(v => v.affectedPackage === filter.package);
      }
    }

    return vulnerabilities.sort((a, b) => {
      // Sort by severity (critical first) then by CVSS score
      const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
      const severityDiff = severityOrder[b.severity] - severityOrder[a.severity];
      if (severityDiff !== 0) return severityDiff;
      return b.cvssScore - a.cvssScore;
    });
  }

  /**
   * Update vulnerability status
   */
  updateVulnerabilityStatus(id: string, status: Vulnerability['status']): boolean {
    const vulnerability = this.vulnerabilities.get(id);
    if (vulnerability) {
      vulnerability.status = status;
      this.vulnerabilities.set(id, vulnerability);
      return true;
    }
    return false;
  }

  /**
   * Get dependency information
   */
  getDependencyInfo(name: string): DependencyInfo | null {
    return this.dependencies.get(name) || null;
  }

  /**
   * List all dependencies
   */
  listDependencies(): DependencyInfo[] {
    return Array.from(this.dependencies.values());
  }

  /**
   * Get security patches
   */
  listSecurityPatches(status?: SecurityPatch['status']): SecurityPatch[] {
    let patches = Array.from(this.securityPatches.values());
    
    if (status) {
      patches = patches.filter(p => p.status === status);
    }

    return patches.sort((a, b) => b.releaseDate.getTime() - a.releaseDate.getTime());
  }

  /**
   * Get scan history
   */
  getScanHistory(limit?: number): ScanResult[] {
    const history = [...this.scanHistory].sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());
    return limit ? history.slice(0, limit) : history;
  }

  /**
   * Calculate vulnerability summary
   */
  private calculateVulnerabilitySummary(vulnerabilities: Vulnerability[]): ScanResult['summary'] {
    const summary = {
      total: vulnerabilities.length,
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
    };

    for (const vuln of vulnerabilities) {
      summary[vuln.severity]++;
    }

    return summary;
  }

  /**
   * Generate recommendations based on vulnerabilities
   */
  private generateRecommendations(vulnerabilities: Vulnerability[]): string[] {
    const recommendations: string[] = [];
    const severityCounts = this.calculateVulnerabilitySummary(vulnerabilities);

    if (severityCounts.critical > 0) {
      recommendations.push(`Address ${severityCounts.critical} critical vulnerabilities immediately`);
    }

    if (severityCounts.high > 0) {
      recommendations.push(`Plan to fix ${severityCounts.high} high-severity vulnerabilities within 7 days`);
    }

    if (severityCounts.medium > 5) {
      recommendations.push(`Consider addressing ${severityCounts.medium} medium-severity vulnerabilities`);
    }

    // Package-specific recommendations
    const packageCounts = new Map<string, number>();
    for (const vuln of vulnerabilities) {
      const count = packageCounts.get(vuln.affectedPackage) || 0;
      packageCounts.set(vuln.affectedPackage, count + 1);
    }

    for (const [pkg, count] of packageCounts.entries()) {
      if (count > 3) {
        recommendations.push(`Package '${pkg}' has ${count} vulnerabilities - consider updating or replacing`);
      }
    }

    return recommendations;
  }

  /**
   * Generate scan ID
   */
  private generateScanId(): string {
    return `scan_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
  }

  /**
   * Generate patch ID
   */
  private generatePatchId(): string {
    return `patch_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
  }

  /**
   * Get vulnerability management report
   */
  getVulnerabilityReport(): {
    totalVulnerabilities: number;
    vulnerabilitiesBySeverity: Record<string, number>;
    openVulnerabilities: number;
    fixedVulnerabilities: number;
    outdatedDependencies: number;
    availablePatches: number;
    appliedPatches: number;
    lastScanDate: Date | null;
    recommendations: string[];
  } {
    const vulnerabilities = this.listVulnerabilities();
    const dependencies = this.listDependencies();
    const patches = this.listSecurityPatches();
    
    const vulnerabilitiesBySeverity = this.calculateVulnerabilitySummary(vulnerabilities);
    const openVulnerabilities = vulnerabilities.filter(v => v.status === 'open').length;
    const fixedVulnerabilities = vulnerabilities.filter(v => v.status === 'fixed').length;
    const outdatedDependencies = dependencies.filter(d => d.isOutdated).length;
    const availablePatches = patches.filter(p => p.status === 'available').length;
    const appliedPatches = patches.filter(p => p.status === 'applied').length;
    
    const lastScan = this.scanHistory.length > 0 
      ? this.scanHistory[this.scanHistory.length - 1].timestamp 
      : null;

    const recommendations = this.generateRecommendations(vulnerabilities.filter(v => v.status === 'open'));

    return {
      totalVulnerabilities: vulnerabilities.length,
      vulnerabilitiesBySeverity,
      openVulnerabilities,
      fixedVulnerabilities,
      outdatedDependencies,
      availablePatches,
      appliedPatches,
      lastScanDate: lastScan,
      recommendations,
    };
  }

  /**
   * Export vulnerability data
   */
  exportVulnerabilityData(): {
    vulnerabilities: Vulnerability[];
    dependencies: DependencyInfo[];
    patches: SecurityPatch[];
    scanHistory: ScanResult[];
    exportDate: Date;
  } {
    return {
      vulnerabilities: this.listVulnerabilities(),
      dependencies: this.listDependencies(),
      patches: this.listSecurityPatches(),
      scanHistory: this.getScanHistory(),
      exportDate: new Date(),
    };
  }
}

// Export singleton instance
export const vulnerabilityManagementService = VulnerabilityManagementService.getInstance();
export default vulnerabilityManagementService;